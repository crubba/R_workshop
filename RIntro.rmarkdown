---
title: "Introduction to R"
subtitle: MA and PhD Course (University of Zurich)
author: "Marco Steenbergen & Christian Rubba"
date: "September 11, 2015"
output: 
  html_document:
    toc: true
    css: bootstrap-3.3.1/css/flatly.min.css
    #theme: flatly
    highlight: tango
    pandoc_args: [
      "+RTS", "-K112m",
      "-RTS"
    ]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```


[html Version](http://christianrubba.com/courses/RIntro/html/RIntro.html) [PDF Version](http://christianrubba.com/courses/RIntro/pdf/RIntro.pdf)
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.


# Start
Dieser Workshop unterrichtet die Grundlagen der statistischen Programmiersprache R. Das Ziel ist es interessierten Studenten in prägnanter und beispielorientierter Art und Weise zu zeigen, wie typische Probleme der wissenschaftlichen Datenanalyse mit R gelöst werden. Wir betrachten zunächst ganz grundsätzliche Operationen und die zur Verfügung stehenden Datenstrukturen in R. Wir zeigen dann, wie externe Daten geladen werden, gesäubert und manipuliert werden können. Die Datenvisualisierung ist ein essentieller Bestandteil jeder Datenanalyse. Wir stellen Pakete und Funktionen vor mit denen publikationsreife Grafiken erstellt werden können. Schlussendlich widmen wir uns der statistischen Modellierung von Daten. Dabei liegt unser Fokus auf der Implementierung verschiedener Regressionsmodelle. Wir erläutern die allgemeine Syntax der Modelle, zeigen Wege zur Überprüfung der Modellannahmen und präsentieren Möglichkeiten die Resultate substantiell zu interpretieren. 

## Wieso R?
Zur Durchführung statistischer Analysen am Computer 

- kostenlos
- für alle gängigen Betriebssysteme erhältlich
- in Umfang und Qualität besser als viele kommerzielle Statistikprogramme. 
- Standard in vielen wissenschaftlichen Communities, u.a. in Politikwissenschaft
- grosse Community (=Hilfe)
- Vielseitige Programmiersprache


## Paketinstallation
- Mit der Installation von R werden zugleich sehr grundsätzliche Funktionen zur Durchführung statistischer Analyse installiert (base R). Weitere Funktionalität kann in Form von Paketen geladen werden, die von jedem geschrieben werden können und auf Internetservern zum Download angeboten werden. Der zentrale Server von dem diese Pakete heruntergeladen werden heisst CRAN. 
- Innerhalb R können neue Pakete mit der Funktion install.packages("package-name") installiert werden. Wird diese Funktion zum ersten Mal verwendet, fragt R von welchem Server das Paket herunterladen werden soll. Benutzt in diesem Fall einen Server in eurer Nähe.
- Zum Installieren der Pakete, auf die im Skript zurückgegriffen wird, folgenden Befehl ausführen:

```{r, eval = F}
pkgs <- c("readr", "haven", "dplyr", "ggplot2", "magrittr", "devtools")
install.packages(pkgs)
```

- Regelmässig erscheinen neuere Versionen von Pakete, die Bugs in alten Versionen beheben oder neue Funktionalität bieten. Zu einem späteren Zeitpunkt können mittels `update_packages(ask = FALSE)` aktualisiert werden.

## Daten
```{r, eval = F}
setwd("your working directory")
data_src <- list(
  "http://christianrubba/lehre/data/1.csv"
  
)

lapply(data_scr, download.file)
```


# Saubere Daten (tidy data)
Ein Grossteil der Arbeit . The two most important properties of tidy data are:

Arranging your data in this way makes it easier to work with because you have a consistent way of referring to variables (as column names) and observations (as row indices). When use tidy data and tidy tools, you spend less time worrying about how to feed the output from one function into the input of another, and more time answering your questions about the data.

- Beobachtungen sind in den Reihen
- Variablen sind in den Spalten
- Alle Informationen sind in einem Datensatz enthalten


![Alt text](img/data1.png)
![Alt text](img/data2.png)
![Alt text](img/data3.png)


# Daten lesen, Daten schreiben
read.csv(), 

* Delimited files with read_delim(), read_csv(), read_tsv(), and read_csv2().
* Fixed width files with read_fwf(), and read_table().
* Web log files with read_log().


## CSV files
```{r}
read.csv("~/Dropbox/Lehre/RIntro/data/voter_buying.tab", sep = "\t", header = T)
```

```{r}
library(haven)
```

### Stata (.dta)

## Excel


# R Grundlagen

## Mathematische Operationen

```{r}
10-5
4^2
(20/6)-4^2

# Arithmetische Operatoren
#+,-,*,/,^,%/%

x <- log(5) #Zuweisungsoperator ("gets"-operator) <- . x wurde im Workspace angelegt und kann zu einem späteren Zeitpunkt wieder aufgerufen werden. Neuere Versionen erlauben ebenfalls das "="-Zeichen zum Abspeichern von Objekten (wovon allerdings abgeraten wird)
x

ls() #Alle Objekte innerhalb des Workspaces werden angezeigt
```

## Datenstrukturen
In den Sozialwissenschaften überwiegt, beispielweise Surveys, Wahldaten, . Soziale Netzwerke


## Vektoren
Vektoren sind eindimensionale Datenstrukturen. Für numerische und symbolsiche Werte. Zur Erstellung eines neuen Vektors kann die Funktion c() benutzt werden.

### Numerische Vektoren
```{r}
num_vec <- c(4, 8, 15, 16, 23, 42)
num_vec
mode(num_vec)
str(num_vec)
length(num_vec) #Wieviele Elemente sind in dem Vektor?
```

### Character Vektoren
```{r}
laender <- c("Schweiz", "Frankreich", "Holland", "Belgien")
laender
mode(laender)
```

Der Input für die c() Funktion können einzelne aber auch ganze Vektoren sein.
```{r}
laender2 <- c("Schweden", "Holland")
c(laender, laender2)
```

Beachte: Gemischte Vektoren sind nicht möglich!

```{r}
z <- c(1, 2, "Uri", 4)
z
str(z)
```

Werden numerische und symbolische Werte in einem Vektor gemischt, so wandelt R alle Werte in character um.

#Umwandeln von Vektoren
```{r}
zzchar <- as.character(num_vec)
zznum <- as.numeric(zzchar)
```

### NA Werte
Innerhalb eines Vektors können fehlende Werte (missing values) mit dem Werte NA ausgezeichnet werden:

```{r}
vec_with_NA <- c(1, 2, NA, 4)
is.na(vec_with_NA) # mittels is.na() können missing values identifiziert werden
```

### Boolean
Wie im letzten Beispiel gesehen, benutzt er einen besonderen Vektorentyp um logisch
```{r}
logic_vec <- c(TRUE, FALSE, TRUE, TRUE)
logic_vec
mode(logic_vec)

as.numeric(logic_vec) # logische Vektoren können in numerische Vektoren umgewandelt werden
which(logic_vec) # which() gibt den Index der TRUE Elemente in einem Vektor
```


Logische Vektoren sind oftmals das Resultate logischer Abfragen:
```{r}
num_vec > 15
laender == "Holland"
```

R enthält eine ganze Reihe Operatoren für logische Abfragen

* \<
* \>
* \>=
* \<=
* == 
* is.na()
* & (logisches UND)
* \| (logisches ODER)
* \! (logisches NICHT)

### Repetition
Oftmals müssen wir Vektoren erstellen, die ein bestimmtes Muster aufweisen. Wenn wir einen Vektor erzeugen wollen in dem sich Werte wiederholen, nutzen wir rep():

```{r}
rep(x = 10, each = 3)
rep(10, 3)
rep(c("Ping","Pong"), 3)
rep(x, 2)
rep(0:1, c(7,3))
```

### Sequenzen
Ein anderes häufig auftretendes Muster ist eine Zahlensequenz. Zahlensequenzen können effizient mit der seq() Funktion generiert werden:

```{r}
0:5
seq(from = 0, to = 5, by = 1) 
seq(0, 5)
seq(5, 50, by = 5) # rückwärtslaufender Index
seq(100, 0, -10)
seq(0, 10, length.out = 35) #äquidistanter Zahlenvektor
```

```{r}
vec <- c("a", "b", "c", "d")
seq_along(vec) # das ist identisch zu 1:length(vec)
```

## Indexierung
```{r}
laender[2]
num_vec[1:6] #xzz[seq(1,6)], xzz[c(1,2,3,4,5,6)]
num_vec[c(1, 3)]
num_vec[-1] # negativer Index ist Möglich. Ausschluss des ersten Elementes

this.value <- 2
num_vec[this.value]
num_vec[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE)]
```


```{r}
#---------Übung 1---------#

#1. Erstelle einen Vektor x mit den Elementen [0,4,8,12,16,20]. Speichere ihn ab in einem Objekt namens x. 
x <- seq(0, 20, 4)

#2. Erstelle einen Vektor y mit den Elementen [3,3,3,4,4,4,4,5,5,5,5,5]. Speichere ihn ab in einem Objekt namens y.
y <- rep(c(3, 4, 5),c(3, 4, 5))

#3. Füge die ersten 5 Elemente aus dem Vektor x mit den Elementen 2 bis 12 aus dem Vektor y zu einem Vektor z zusammen.
z <- c(x[1:5], y[2:12])

#4. Ersetze jedes zweite Element aus dem Vektor z mit dem quadrierten Wert.
(index <- seq(1, length(z), 2))
z[index] <- z[index]^2
```

## Data frames
Data frames sind zweifellos die üblichste Form in der Daten . Die "rechteckige" Struktur, bedeutet jede Spalte hat genau die gleiche Anzahl an Reihen (und andersrum). Dataframes sind oftmals sehr weit, d.h. verfügen über eine grosse Anzahl an Spalten, oder lang (= verfügen über eine grosse Anzahl an Reihen). Beides bringt ein Problem bei der Darstellung des Dataframes im Terminal mit sich. Um sich einen Überblick über einen Dataframe zu verschaffen, können wir die head() Funktionen verwenden, bei der standardmässig die ersten zwanzig Reihen ausgegeben werden.

Data frames können per Hand mit der Funktion data.frame() erstellt werden:

```{r}
new_df <- data.frame(var2 = c(1,2), var2 = c("a", "b"))
new_df
```

Wir können einzelne Variablen (in den Spalten) direkt ansprechen, entweder durch 

```{r}
new_df$var1
new_df[,1] # Indexierung der ersten Spalte
```

Um einen ersten Eindruck in einen neuen Datensatz zu gewinnen, lohnt es sich oftmals die ersten paar Zeilen des Data Frames anzuschauen:

```{r}
head(df) 
```

Analog dazu funktioniert tail(), welches die letzten 20 Zeilen ausdruckt:

```{r}
tail(df) 
```

Die Variablennamen werden gesondert gespeichert. Wir können sie uns mit der colnames() Funktion ausgeben lassen:

```{r}
colnames(df)
```

Um spezfische Elemente des Variablennamenvektors zu modifizieren benutzen wir die oben erwähnte Indizierungstechnik. Wollten wir den Variablennamen der ersten Spalten umändern, so

```{r}
colnames(df)[1] <- "JAHR"
```

Analog zu den Spaltennamen können auch die Reihen . rownames(df)


## Lists
Listen sind eine weitere Datenstrutkur auf die im Prozess der Datenanalyse oftmals zurückgegriffen wird. Listen sind die generellste Form Daten zu speichern.  Eine Liste ist im seltensten Fall das Dataformat, das wir benutzen wollen, um Daten für die Analyse zu speichern. Es ist oftmals vielmehr ein intermediäres Datenformat.

```{r}
ourList <- list(zahlen = c(1,2,3), 
                president = "Obama", 
                df = data.frame(x = c(1,2), y = c(2,4)))
ourList
```

Listen können genauso wie andere Objekte indiziert werden. Hierzu wird ein doppeltes Klammernpaar verwendet (LISTNAME[[INDEX]]), wobei INDEX die Position des Elementes angibt oder durch Benutzen des Namens des Listenelementes.

```{r}
ourList[[2]]
ourList$president
```

Auch Listenelemente können mit <- überschrieben werden:

```{r}
ourList[[2]] <- "Bush"
ourList
```

### Listeniteration
lapply übt eine Funktion über jedes einzelne Listenelement aus.

```{r}
voteList <- list(zurich = sample(c(0,1,NA), 1000, replace = T, prob = c(0.25, 0.65, 0.1)),
                 zug = sample(c(0, 1, NA), 1000, replace = T, prob = c(0.43, 0.29, 0.28)),
                 wallis = sample(c(0, 1, NA), 1000, replace = T, prob = c(0.5, 0.3, 0.2)))
```



```{r}
sumYes <- lapply(voteList, sum)
sumYes
```

```{r}
lapply(voteList, mean, na.rm = T)
```

unlist
```{r}
unlist(results)
```



##  Weitere grundlegende Operationen

### Funktionen

Eine Funktion hat:
- einen Namen 
- Argument(e)
- Body
- Rückgabewert

Diese einfache Funktion addiert 1 zu einem beliebigen Eingabewert
```{r}
plus1 <- function(x) {
  return(x + 1)
}
```


```{r}
plus1(x = 1)
plus1(x = 51239)
plus1(2) # 
```

Was passiert wenn wir als Input einen String angeben?

```{r, error = TRUE}
plus1("genf")
```


```{r}
plus1x <- function(x) {
  if(!is.numeric(x)){
    stop("x muss numerisch sein!!!")
  }
  return(x + 1)
}
```

```{r, error = TRUE}
plus1x("genf")
```


```{r, error = TRUE}
# return values ---
plus1 <- function(x) {
  x + 1
}

plus1_1 <- function(x) {
  11 + 23
  x + 1
  x + 10
}

plus1_1(1)
plus1_1(2)

plus1_2 <- function(x) {
  return(x + 1)
  5
}

plus1_2(2)

plus1_3 <- function(x) {
  return(x + 1)
  print("This text is never printed :-(")
  lm() # this error is never raised
  print("This is not printed either.")
}

plus1_3(2)

# default argument ---
add <- function(x, y = 1) x + y
add(x = 1)
add(x = 1, y = 8)
```

- Eine Funktion kann selbstverständlich mehr als ein Argument haben

```{r}
add <- function(x, y) sqrt(x + y)
add(19, 6)
```


# (*) scoping ---

```{r, eval = FALSE}
plus2 <- function(x) {
  print(paste("x equals", x))
  x + 2
}

plus2(1)

x # Lookup error

plus3 <- function(x) {
  x1 + 3
}
# no error here, "x1" could be available in when function is used

plus3(20)
# now an error is raised because the x1 is not available in the global namespace

x1 <- 20

plus3(1)
# uses x1 = 20 from global namespace and not x = 1 from function


# Conditionals -------------------------------------------------------
addpositive <- function(x) {
  if (x > 0) {
    x + 1
  }
}

addpositive(1)
addpositive(-1) # returns NULL that does not print anything

# add another action when
addpositive <- function(x) {
  if (x > 0) {
    return(x + 1)
  }
  if (x <= 0) {
    return(NA)
  }
}

# use "else" to capture all cases where if() is FALSE
addpositive <- function(x) {
  if (x > 0) {
    return(x + 1)
  } else {
    return(NA) # alternative for type stability: NA_real_
  }
}

addpositive(1)
addpositive(-1)


## useful example
absval <- function(x) {
  if (is.na(x)) {
    return(NA)
  }

  if (x < 0) {
    out <- -x
  } else {
    out <- x
  }

  return(out)
}

absval(2)
absval(-2)
absval(NA)
```


```{r}
myFun <- function(x){
  y <- sum(x)^2
  return(y)
}
```


## Loops

```{r}
x <- c("apples", "oranges", "bananas", "strawberries")
```

```{r}
for (i in x) {
    print(x[i])
}
```

```{r}
for (i in 1:4) {
    print(x[i])
}
```

```{r}
for (i in seq(x)) {
    print(x[i])
}
```

```{r}
for (i in 1:4) print(x[i])
```

Loops sind eine recht allgemeine Form  Vektorisierte Funktionen


# Daten "säubern"
gather, seperate und spread

```{r}
library(tidyr)
```


```{r}
horse <- separate(horse, FastestHorse, into = c("horse name", "time"), sep = "\\(")
```

Dies kann auch ein regulärer Ausdruck sein.


# Transforming Data
dplyr provides 

```{r}
library(dplyr)
```

## filter and slice
filter() allows you to select a subset of the rows of a data frame. The first argument is the name of the data frame, and the second and subsequent are filtering expressions evaluated in the context of that data frame. takes logical expressions and returns the rows for which all are TRUE

```{r}
```

## arrange
Zum Arrangieren der Ordnung der Reihen kann arrange verwendet werden. 

```{r}
df <- arrange(df)
head(df)
```


```{r}
df <- arrange(df, desc())
head(df)
```

## select and rename

```{r}
df <- select(df, lol)
head(df)
```

## distinct

## mutate and transmute

## Grouped operations

## Piping
Das folgende Beispiel veranschaulicht dies:

```{r}
sum(log(seq(1,1000, 4)))
```

Wir möchten hier die Summe der logarithmierten Sequenz von 1 bis 1000 in vierer Schritten berechnen. Zum Interpretieren dieses Befehls, 

Mit Hilfe des **magrittr** Pakets lässt sich der gleiche Befehl in einer , d.h. so wie 

```{r}
library(magrittr)
seq(1,1000, 2.5) %>% log %>% sum
```

Zur Interpretation dieses Befehls können wir nun von links nach rechts lesen. Wir fangen damit an die Zahlensequenz zu generieren. Das Ergebnis dieser Funktion leiten wir an die Logarithmierungsfunktion weiter. Dazu verwenden wir nun die Funktion `%>%` welcDanach wird das Ergebnis weiter an die Summenfunktion geleitet.  

## Merging data sets

### inner_join
inner_join(x, y): return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned

### semi_join(superheroes, publishers)
semi_join(x, y): return all rows from x where there are matching values in y, keeping just columns from x. A semi join differs from an inner join because an inner join will return one row of x for each matching row of y, where a semi join will never duplicate rows of x.

### left_join(superheroes, publishers)
left_join(x, y): return all rows from x, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned

### anti_join(superheroes, publishers)
anti_join(x, y): return all rows from x where there are not matching values in y, keeping just columns from x



# Plotting


[Official reference](http://docs.ggplot2.org/current/)
[Quick reference](http://sape.inf.usi.ch/quick-reference/ggplot2/geom)

## Die Grammar of Graphics 

Die Syntax ist wie folgt:. Hier für eine Scatterplot zur Darstellung des Zusammenhangs zwischen den Variablen Var1 und Var2: (Abschnitt tidy data)

```{r, eval = F}
library(ggplot2)
gg <- ggplot(data = X) + geom_point(aes(x = Var1, y = Var2))
```

Zum Ausgeben der Grafik muss das Objekt (hier gg) in der Kommandozeile aufgerufen werden

## geom_point
geom_point ist die Funktion zum Abbilden eines Wertes in einem Koordinatensystem. 

```{r, echo=FALSE}

```

## geom_histogram and geom_bar

## geom_smooth

## Facetting

## Theming


Statistische Modelle
============

## Lineare Modelle

* $y_n = \alpha + \beta \times x_n + \epsilon_n$
$\epsilon_n \sim Normal(0, \sigma)$

```{r}
#m1 <- lm(x ~ y, data = )
#summary(m1)
```

## Generalisierte lineare Modelle

## Interpretation substantialler Effekte

Sonstiges
=============

# Style Guides
Variablen- und Funktionsnamen, Klammernregeln, Intendierung, Whitespacing

* [Google's](https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml)
* [Hadley Wickham's](http://adv-r.had.co.nz/Style.html)

Wichtiger als der Stil für den ihr euch entscheidet, ist das er konsequent benutzt wird!

# R Self Hep
[stackoverflow](http://stackoverflow.com/)
[R help](https://stat.ethz.ch/mailman/listinfo/r-help)

# Links & Tutorials
[dplyr vignette](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)
[magrittr vignette](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html)
[Stat 545](https://stat545-ubc.github.io/block009_dplyr-intro.html)
[Twotorials](http://www.twotorials.com/)
[UBC Stat 545](https://stat545-ubc.github.io/)


Citations
============
